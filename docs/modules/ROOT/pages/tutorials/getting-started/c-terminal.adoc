= Getting Started on {product} with the Terminal using C

image:logos/c.svg[role="related thumb right",alt="Programming language logo",width=120,height=120] This tutorial explains how to run applications written in the C programming language on {product} using the command line.

If you are not familiar with issuing commands on a terminal session, you might want to try the xref:tutorials/getting-started/c-web.adoc[Getting Started with C on the OpenShift Web Console] guide instead.

== Requirements

To follow this guide, please make sure that you have the following tools installed:

A web browser:: Google Chrome, Firefox, Microsoft Edge, Safari, or Opera, with JavaScript enabled.

`oc`:: You can download the OpenShift command directly from {product}, selecting the help menu (marked as a question mark) and selecting the "Command line tools" entry.

`docker` or `podman`:: You can download them from https://www.docker.com and https://podman.io.

`curl`:: Available from https://curl.se.

== About the Application

To demo how to run applications written in the https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29[C] programming language on {product}, we will use a small demo application using the https://www.gnu.org/software/libmicrohttpd/[GNU libmicrohttpd library], bundled as a container thanks to its corresponding `Dockerfile`, and ready to be used on {product}.

You can browse the full source code of this application on GitLab: https://gitlab.com/vshn/applications/fortune-c

The "Fortune in C" application does a few simple things:

* When invoked on the browser, it returns a random number and a funny quote.
* When invoked with an HTTP request including the `Accept: application/json` header, it returns the same information in JSON format.
* Finally, when invoked with an HTTP request including the `Accept: text/plain` header, it returns the same information in plain text format.

Learn more about the `fortune-c` application, including how to edit and build it, on the https://gitlab.com/vshn/applications/fortune-c/-/blob/master/README.adoc[project README].

=== The Router

The code below shows the main router of the application in the C programming language, located at https://gitlab.com/vshn/applications/fortune-c/-/blob/master/src/main.c[src/main.c], courtesy of the https://www.gnu.org/software/libmicrohttpd/[GNU libmicrohttpd library].

[source,c,indent=0]
--
int handler(void *cls, struct MHD_Connection *connection,
                         const char *url,
                         const char *method, const char *version,
                         const char *upload_data,
                         size_t *upload_data_size, void **con_cls)
{
    char fortune[100000] = { "" };
    int result = execute_command(fortune, "fortune");
    char hostname[100] = { "" };
    result = execute_command(hostname, "hostname");
    int random = rand() % 1000;

    char page[200000] = { "" };
    const char *accept_header = MHD_lookup_connection_value (connection, MHD_HEADER_KIND, "Accept");
    if (strcmp(accept_header, "application/json") == 0) {
        result = respond_json(page, fortune, hostname, random);
    }
    else if (strcmp(accept_header, "text/plain") == 0) {
        result = respond_text(page, fortune, random);
    }
    else {
        result = respond_html(page, fortune, hostname, random);
    }
    struct MHD_Response *response;
    int ret;

    response = MHD_create_response_from_buffer(strlen(page),
                                               (void *)page, MHD_RESPMEM_PERSISTENT);
    ret = MHD_queue_response(connection, MHD_HTTP_OK, response);
    MHD_destroy_response(response);

    return ret;
}
--

=== Run the Container

This step is optional; you can easily test the application locally with Docker or Podman:

[source,shell]
--
$ docker run --rm --publish 8080:8080 registry.gitlab.com/vshn/applications/fortune-c:latest
$ podman run --rm --publish 8080:8080 registry.gitlab.com/vshn/applications/fortune-c:latest
--

Now you can test the application with `curl`:

[source,shell]
--
$ curl http://localhost:8080 --header "Accept: application/json"
$ curl http://localhost:8080 --header "Accept: text/plain"
--

You can also open a browser and navigate to http://localhost:8080 to get your fortune cookie of the day.

=== Dockerfile

The application includes a https://gitlab.com/vshn/applications/fortune-c/-/blob/master/Dockerfile[Dockerfile] ready to build a container fully compatible with OpenShift. The snippet below shows the instructions used to build the actual running image:

[source,dockerfile,indent=0]
--
# Step 2: Production image
FROM busybox:glibc
COPY --from=builder /builder/build/c-fortune /usr/local/bin/c-fortune
COPY --from=builder /usr/local/lib/libjson-c.so.5 /usr/local/lib/libjson-c.so.5
COPY --from=builder /usr/games/fortune /usr/local/bin/fortune
COPY --from=builder /usr/share/games/fortunes /usr/share/games/fortunes
COPY --from=builder /usr/lib/x86_64-linux-gnu/libmicrohttpd.so.12 /usr/lib/x86_64-linux-gnu/libmicrohttpd.so.12
COPY --from=builder /usr/lib/x86_64-linux-gnu/libgnutls.so.30 /usr/lib/x86_64-linux-gnu/libgnutls.so.30
COPY --from=builder /usr/lib/x86_64-linux-gnu/libp11-kit.so.0 /usr/lib/x86_64-linux-gnu/libp11-kit.so.0
COPY --from=builder /usr/lib/x86_64-linux-gnu/libidn2.so.0 /usr/lib/x86_64-linux-gnu/libidn2.so.0
COPY --from=builder /usr/lib/x86_64-linux-gnu/libunistring.so.2 /usr/lib/x86_64-linux-gnu/libunistring.so.2
COPY --from=builder /usr/lib/x86_64-linux-gnu/libtasn1.so.6 /usr/lib/x86_64-linux-gnu/libtasn1.so.6
COPY --from=builder /usr/lib/x86_64-linux-gnu/libnettle.so.8 /usr/lib/x86_64-linux-gnu/libnettle.so.8
COPY --from=builder /usr/lib/x86_64-linux-gnu/libhogweed.so.6 /usr/lib/x86_64-linux-gnu/libhogweed.so.6
COPY --from=builder /usr/lib/x86_64-linux-gnu/libgmp.so.10 /usr/lib/x86_64-linux-gnu/libgmp.so.10
COPY --from=builder /usr/lib/x86_64-linux-gnu/libffi.so.7 /usr/lib/x86_64-linux-gnu/libffi.so.7
COPY --from=builder /usr/lib/x86_64-linux-gnu/librecode.so.0 /usr/lib/x86_64-linux-gnu/librecode.so.0
COPY --from=builder /lib/x86_64-linux-gnu/libdl.so.2 /lib/x86_64-linux-gnu/libdl.so.2

EXPOSE 8080

# <1>
USER 1001:0

CMD ["/usr/local/bin/c-fortune"]
--
<1> This explicitly prevents the container from running as root; this is a requirement of OpenShift, and a good practice for images in general.

You can use the `Dockerfile` above to build your own copy of the container, which you can then push to the registry of your choice:

[source,shell]
--
$ git clone https://gitlab.com/vshn/applications/fortune-c.git
$ cd fortune-c
$ docker build -t fortune-c .
$ podman build -t fortune-c .
--

== Step 1: Create a Project

Follow these steps to login to {product} on your terminal, create a project, and to deploy the application:

. Login to the {product} console with your web browser.
. Click on your user name on the top right and select "Copy login command"
. Click "Display token" and copy the login command shown in "Log in with this token"
. Paste the `oc login` command on the terminal:
+
[source,shell]
--
$ oc login --token=sha256~_xxxxxx_xxxxxxxxxxxxxxxxxxxxxx-xxxxxxxxxx-X --server=https://api.[YOUR_PREFERRED_ZONE].appuio.cloud:6443
$ oc projects
You are not a member of any projects. You can request a project to be created with the 'new-project' command.
--

. Create a new project called "fortune-c"
+
[source,shell]
--
$ oc new-project fortune-c
Now using project "fortune-c" on server "https://api.[YOUR_PREFERRED_ZONE].appuio.cloud:6443".

You can add applications to this project with the 'new-app' command. For example, try:

    oc new-app rails-postgresql-example

to build a new example application in Ruby. Or use kubectl to deploy a simple Kubernetes application:

    kubectl create deployment hello-node --image=k8s.gcr.io/serve_hostname
--

. To deploy the application we will use a standard Kubernetes `Deployment` object. Save the following YAML in a file called `deployment.yaml`:
+
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fortune-c
  namespace: fortune-c # <1>
  labels:
    app: fortune-c
spec:
  template:
    spec:
      imagePullSecrets:
      - name: gitlab-pull-secret
      containers:
      - image: registry.gitlab.com/vshn/applications/fortune-c:latest
        imagePullPolicy: Always
        name: fortune-container
        ports:
        - containerPort: 8080
    metadata:
      labels:
        app: fortune-c
  selector:
    matchLabels:
      app: fortune-c
  strategy:
    type: Recreate
---
apiVersion: v1
kind: Service
metadata:
  name: fortune-c
  namespace: fortune-c # <1>
  labels:
    app: fortune-c
spec:
  ports:
    - port: 8080
      targetPort: 8080
  selector:
    app: fortune-c
  type: ClusterIP
----
<1> Make sure this annotation matches exactly the name of your project: `fortune-c`

. Then apply the deployment to your {product} project and wait until your pod appears with the status "Running":
+
[source,shell]
--
$ oc -n fortune-c apply -f deployment.yaml
deployment.apps/fortune-c created
service/fortune-c created
$ oc -n fortune-c get pods --watch
NAME                         READY   STATUS    RESTARTS   AGE
fortune-c-6fbd5484cf-k47gt   1/1     Running   0          11s
--

== Step 2: Publish your Application

At the moment your container is running but it is not available from the Internet. To be able to access our application, we must create an `Ingress` object.

. Create another file called `ingress.yaml` with the following contents, customizing the parts marked as `[YOUR_APP_NAME]` and `[YOUR_PREFERRED_ZONE]` to your liking:
+
[source,yaml]
--
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-production
  name: fortune-c-ingress
  namespace: fortune-c # <1>
spec:
  rules:
  - host: [YOUR_APP_NAME].apps.[YOUR_PREFERRED_ZONE].appuio.cloud # <2>
    http:
      paths:
      - pathType: Prefix
        path: /
        backend:
          service:
            name: fortune-c
            port:
              number: 8080
  tls:
  - hosts:
    - [YOUR_APP_NAME].apps.[YOUR_PREFERRED_ZONE].appuio.cloud
    secretName: fortune-c-cert
--
<1> Make sure this annotation matches exactly the name of your project: `fortune-c`
<2> Replace the placeholders `YOUR_APP_NAME` and `YOUR_PREFERRED_ZONE` with valid values.

. Apply the ingress object to your {product} project and wait until you route shows as available.
+
[source,shell]
--
$ oc -n fortune-c apply -f ingress.yaml
ingress.networking.k8s.io/fortune-c-ingress created
$ oc -n fortune-c get routes --watch
NAME                      HOST/PORT                                         PATH   SERVICES    PORT    TERMINATION     WILDCARD
fortune-c-ingress-4pk2j   fortune-c.apps.[YOUR_PREFERRED_ZONE].appuio.cloud   /      fortune-c   <all>   edge/Redirect   None
--

. After a few seconds, you should be able to get your daily fortune message using `curl`!
+
[source,shell]
--
$ curl https://[YOUR_APP_NAME].apps.[YOUR_PREFERRED_ZONE].appuio.cloud --header "Accept: text/plain"
$ curl https://[YOUR_APP_NAME].apps.[YOUR_PREFERRED_ZONE].appuio.cloud --header "Accept: application/json"
--

== Step 3: There's no Step 3!

The "Fortune in  C" application is now running on {product}. Congratulations!

What's next? To run your own application written in C or using the GNU libmicrohttpd library application on {product}, follow these steps:

* Containerize the application making sure it is compatible with {product}. The `Dockerfile` above can serve as a starting point.
* Enhance the deployment for your application with liveness and health probes, or better yet, create a https://helm.sh/[Helm] chart.
* Configure your CI/CD system to automatically deploy your application to your cluster.
* When you're done testing the fortune application, delete the `fortune-c` project with the following command:
+
[source,shell]
--
$ oc delete project fortune-c
--